- This level again stresses over our skills of injection and control
- We are given a page wherein we can edit our name, and that's it
- The mimic source code looks like this:
```php
<?php
function debug($msg) { /* {{{ */
	if(array_key_exists("debug", $_GET)) {
		print "DEBUG: $msg<br>";
	}
}
function print_credentials() { /* {{{ */
	if($_SESSION and array_key_exists("admin", $_SESSION) and $_SESSION["admin"] == 1) {
		print "You are an admin. The credentials for the next level are:<br>";
		print "<pre>Username: natas21\n";
		print "Password: <censored></pre>";
	} else {
	print "You are logged in as a regular user. Login as an admin to retrieve credentials for natas21.";
	}
}
/* we don't need this */
function myopen($path, $name) {
	//debug("MYOPEN $path $name");
	return true;
}

/* we don't need this */
function myclose() {
	//debug("MYCLOSE");
	return true;
}

function myread($sid) {
	debug("MYREAD $sid");
	if(strspn($sid, "1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM-") != strlen($sid)) {
		debug("Invalid SID");
		return "";
	}
	$filename = session_save_path() . "/" . "mysess_" . $sid;
	if(!file_exists($filename)) {
		debug("Session file doesn't exist");
		return "";
	}
	debug("Reading from ". $filename);
	$data = file_get_contents($filename);
	$_SESSION = array();
	foreach(explode("\n", $data) as $line) {
		debug("Read [$line]");
		$parts = explode(" ", $line, 2);
		if($parts[0] != "") $_SESSION[$parts[0]] = $parts[1];
	}
	return session_encode() ?: "";
}

function mywrite($sid, $data) {
// $data contains the serialized version of $_SESSION
// but our encoding is better
	debug("MYWRITE $sid $data");
	// make sure the sid is alnum only!!
	if(strspn($sid, "1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM-") != strlen($sid)) {
		debug("Invalid SID");
		return;
}
	$filename = session_save_path() . "/" . "mysess_" . $sid;
	$data = "";
	debug("Saving in ". $filename);
	ksort($_SESSION);
	foreach($_SESSION as $key => $value) {
		debug("$key => $value");
		$data .= "$key $value\n";
	}
	file_put_contents($filename, $data);
	chmod($filename, 0600);
	return true;
}
/* we don't need this */
function mydestroy($sid) {
	//debug("MYDESTROY $sid");
	return true;
}

/* we don't need this */
function mygarbage($t) {
	//debug("MYGARBAGE $t");
	return true;
}
session_set_save_handler(
"myopen",
"myclose",
"myread",
"mywrite",
"mydestroy",
"mygarbage");

session_start();

if(array_key_exists("name", $_REQUEST)) {
	$_SESSION["name"] = $_REQUEST["name"];
	debug("Name set to " . $_REQUEST["name"]);
}
print_credentials();
$name = "";
if(array_key_exists("name", $_SESSION)) {
	$name = $_SESSION["name"];
}
?>
```
- So there's a lot going on in this code, and just like the [[Natas19_to_Natas20|previous level]], we have been provided with a `print_credentials()` function that will print the password of the next level if our session has the value of `admin` variable set to `1`
- However, this time the session is being populated with the details saved in a flat file, which is referenced by the session ID that is either generated by PHP itself, or we can pass in an existing session ID which can reference a file
- The `mywrite()` and `myread()` methods are of importance to us. Rest of the stuff is either just stub code or some PHP internal which we will not need that much in this level
- There can be two methods to solve this level:
	- Bruteforcing a session ID in order to guess the already existing session ID of an admin user (Similar to the approach that we had used in a few levels before)
	- Generate a user controlled session that can give us the access
- The first approach is a bit tough as the session IDs generated this time are pretty random and there's no simple way to guess them. Here are a few of those IDs that were sent back in response when I tried in BurpSuite:
```text
6v1lcdngeqe6ppjlnqn27grqcr 
pt1s62m7j0fveolbn31jm1h2uh 
qbidt58lrhnleak9vb4et5n4uc 
g9dieqk9ps8qqo11964k9dqd6s 
n5g9lsu6etdia4hp14rf9a2vhe 
201mkoaorgia3oa8dkcqr48og9 
m89bmmp5t652o64q5qjsf86b52 
ulq0jl7fpvslpqhcm1539upnac 
2kjf3g3fcn5b0h6hb4imsk38om 
bj098liihog49d60b8ltqe1v10 
ufvc7fq1r96jujjqno0g69dsf2 
jdmqj1ab60fsm7pnlijnjihp8v
```
- These IDs didn't seem to follow any encoding rule or pattern so I gave up on this approach and started to think of the other one
- If we look closely at the `mywrite()` method, we can see that it is writing the values of the keys present in the `$_SESSION` superglobal in the flat file
- Also, we can see in the following snippet, the value of the `name`variable inside the `$_SESSION` superglobal is being set from the request body:
```php
if(array_key_exists("name", $_REQUEST)) {
	$_SESSION["name"] = $_REQUEST["name"];
	debug("Name set to " . $_REQUEST["name"]);
}
```
- This means, there is a possibility that we can control the data that is being written to the session's flat storage file
- So what content should we write to the file? Well, this can be answered by looking at the code that is reading the session's flat file:
```php
foreach(explode("\n", $data) as $line) {
	debug("Read [$line]");
	$parts = explode(" ", $line, 2);
	if($parts[0] != "") $_SESSION[$parts[0]] = $parts[1];
}
```
- This code does the following:
	- Reads the flat file
	- Separates it by newlines (`\n`)
	- Separates each line by a single space (`" "`)
	- Adds the first part as key and second part as value in the `$_SESSION`
- Combining this with the condition in `print_credentials()` method, we can see that it checks the presence of `admin` key in the `$_SESSION` superglobal and checks if its value is set to `1`
- So essentially, we need to write a parameter named `admin` in the flat file and set its value to `1`
- Our flat file contents might look like this:
```text
name test
admin 1
```
- The property `name` is present because it is the only property that is being written to the flat file. However, what value we can write on it, is totally up to us as there is no check to sanitise or verify that
- Hence, to solve this challenge, we fire up BurpSuite, and navigate to the `Proxy` tab
- We need to have our BurpSuite proxy configured already in the browser. If it hasn't been done, the easy to follow instructions are provided by PortSwigger [here](https://portswigger.net/burp/documentation/desktop/external-browser-config)
- We will have to intercept the incoming request that will be sent by the browser. This can be done as follows:
	- Go to the Proxy tab in BurpSuite
	- Turn on the intercept mode, and submit the form on the web page. The request will show up in Burp like this:
	![[Pasted image 20240919175828.png]]
	- Right click on the request and select the `Send to repeater` option. This will copy all the details of the request in the `Repeater` tab which can be used to fire the request over and over again
- Once we have the request on our end, we can turn off the intercept and carry on in BurpSuite itself
- In the repeater tab, we can see that the request is present in the HTTP format with all the details that we need
![[Pasted image 20240919180302.png]]
- First, we remove the PHPSESSID cookie that is present already, as right now we don't have any session that would be useful to us
- We also set the value of `debug` query parameter to true, which would help us to see the queries that are being performed
- And also, we add the request body parameters as follows:
```text
name=admin
admin 1
```
- Since our input is not sanitised, we can send any arbitrary input, and in our case we need to send the value of `admin` property to be written to the file, with a newline. So our modified request looks like this:
![[Pasted image 20240919180713.png]]
- We fire the request, and on the right hand side, we receive a response like this:
![[Pasted image 20240919180919.png]]
- Note that at the end of the `html` body, a session file with our intended data has been saved with the unique ID `cc7o3v3e4u1m12n504a22q2suq`
- Now we set the same ID in our cookie with `PHPSESSID` key
- Our modified request looks like follows:
![[Pasted image 20240919181118.png]]
- We now fire this request, and boom! Our saved data is read by the `myread()` method, and is tricked into believing that the value of `admin` property is set to `1` :)
- This is exactly what we were expecting, which is confirmed by the response:
![[Pasted image 20240919181245.png]]
- Sometimes this response doesn't come up immediately after the request, so if we send the same request again, the response will come up
- We obtain the password: BPhv63cKE1lkQl04cE5CuFTzXe15NfiH 